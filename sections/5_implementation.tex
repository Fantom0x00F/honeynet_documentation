\section{Реализация системы автоматического разворачивания ОбС}

По выработанной высокоуровневой архитектуре системы было разработано программное обеспечение, состоящее из двух исполняемых файлов: центральный узел и модуль агента.

\subsection{Реализация центрального узла}

К реализации центрального узла не предъявлялось никаких специфичных технологических требований, вся его деятельность сводится к поддержанию соединения по протоколу \textit{WebSocket} и коммуникации с агентами. По этой причине использовался технологический стек, состоящий из наиболее распространенных, либо наиболее привычных разработчику инструментов:
\begin{itemize}
	\item в качестве языка программирования использовался язык \textit{Kotlin};
	\item для сохранения текущего состояния системы и происходящих событий использовалась \textit{MySQL} база данных;
	\item решение разрабатывалось по принципу инверсии управления с использованием фреймворка \textit{Spring Boot};
	\item для реализации генетического алгоритма использовалась библиотека \textit{jMetal}.
\end{itemize}

Выбор базирующегося на \textit{JVM} языка позволил получить на выходе кроссплатформенное решение, не зависящее от исполняемого окружения, что должно упростить жизнь потенциальным клиентам системы автоматического разворачивания обманной системы, а использование фреймворка \textit{Spring Boot} позволило получить самодостаточный исполняемый \textit{jar} файл, тем самым исключив необходимость установки сервера приложений.

Подключение сторонней библиотеки \textit{jMetal} исключило необходимость реализации выбранного генетического алгоритма \textit{NSGAII}, позволив сконцентрировать внимание на реализации операторов алгоритма. Библиотека существенно упрощает сложность реализации математической части разрабатываемой системы. Процедура получения решения по переданной конфигурации сети представлепна ниже.

\begin{lstlisting}[style=kotlinstyle, label=lst:crossover]
	fun solve(networkConfiguration: NetworkConfiguration) {
	    val honeypotProblem = HoneypotProblem(networkConfiguration, initialSolutionGenerator)
	    //инициализация алгоритма
	    val genetic = NSGAIIBuilder<HoneypotSolution>(honeypotProblem,
	                DistributionCrossover(), 
	                Mutation())
	            .setPopulationSize(100)
	            .setMaxEvaluations(100000)
	            .build()
	    //запуск алгоритма
	    genetic.run()
	    //выбор оптимального решения
	    var distributions = genetic.population.map { it.honeysDistribution }.toList()
	    distributions = distributions.sortedWith(Comparator { a, b ->
	        val r = a.first.compareTo(b.first)
	        return@Comparator if (r != 0) r else a.second.compareTo(b.second)
	    })

	    distributions[0].third.apply(networkConfiguration)
	}
\end{lstlisting}

Работа с центральным узлом происходит посредством \textit{web} интерфейса, который позволяет производить следующие действия:
\begin{itemize}
	\item загружать топологию корпоративной сети посредством конфигурационного файла;
	\item производить добавление агентов в систему;
	\item производить запуск процедуры подбора рекомендуемой конфигурации обманной системы;
	\item вручную модифицировать состояние ловушек на агентах;
	\item просматривать список событий с ловушкек.
\end{itemize}

!!!!!
Вставить про конфигурацию системы
!!!!!


\subsection{Реализация агента}

Наиболее значимые из выдвигаемых к разрабатываемой системе требований возлагаются на сторону агента, так как непосредственное взаимодействие с ловушкой и контроль действий злоумышленника происходят на его стороне.

Большинство операций, производимых на агенте относятся к категории взаимодействий с \textit{docker} контейнерами. Для управления состояниями контейнеров удаленным образом \textit{Docker} предоставляет программный интерфейс, называемый \textit{Engine} \textit{API}. Так как агент является наиболее важным элементом разрабатываемой системы, то необходимо обеспечить наиболее надежную интеграцию с предоставляемым программным интерфейсом.

Существуют реализации клиентских библиотек, обеспечивающих работу с \textit{Engine API}, практически под все популярные языки программирования, однако факт критичности контекста использования рекомендует выбирать реализации, предоставляемые разработчиками \textit{Docker} и обновляемые с каждым последующим выпуском новой версии системы.

\textit{Docker} предоставляет клиентские библиотеки для двух языков программирования: \textit{Go} и \textit{Python}. Учитывая тот факт, что сам \textit{Docker} реализован на \textit{Go}, следует предполагать, что библиотека на данном языке имеет более качественную поддержку со стороны разработчиков. По данной причине модуль агента разрабатывался на языке программирования \textit{Go}.

Реализованный агент позволяет выполнять следующие действия:
\begin{itemize}
\item производить подключение к центральному узлу системы по протоколу \textit{WebSocket} с использованием \textit{SSL} шифрования;
\item по команде от сервера изменять тип контейнера;
\item производить запуск и остановку контейнера по команде от центрального узла;
\item анализировать изменения в файловой системе контейнера и оповещать сервер в случае возникновения таковых;
\item анализировать изменения в списке запущенных процессов и оповещать сервер в случае возникновения таковых.
\end{itemize}

Процедура анализа изменений в файловой системе, не смотря на кажущуюся сложность, представляет собой достаточно простой процесс благодаря тому, что \textit{Engine API} содержит метод получения списка всех измененных, добавленных или удаленных файлов. Таким образом вся процедура отслеживания сводится к периодическому запуску метода программного интерфейса.

\begin{lstlisting}[style=gostyle]
	changes, err := w.cli.ContainerDiff(*w.ctx, w.containerId)
	if err != nil {
	  w.Hub.Events <- events.Event{Type: events.AgentError, Message: err.Error()}
	}
	var changesStr []string //сериализация изменений
	if len(w.containerState.changedFiles) != 0 && !reflect.DeepEqual(w.containerState.changedFiles, changesStr) {
	  w.Hub.Events <- events.Event{Type: events.MotionDetected, Message: "There is changes in filesystem!"}
	  w.Hub.Events <- events.Event{Type: events.MotionDetected, Message: fmt.Sprint(changesStr)}
	}
\end{lstlisting}

Агент содержит три конфигурационных параметра:
\begin{itemize}
	\item адрес центрального узла;
	\item относительный путь для \textit{websocket} подключения;
	\item абсолютный путь расположения корневого сертификата для \textit{SSL} шифрования;
	\item секрет для аутентификации при установке соединения с центральным узлом.
\end{itemize}

Конфигурационные параметры передаются через аргументы командной строки.

Агент не хранит своего состояния и получает его при установке соединения с центральным узлом.